# 个人开发者工作方法论

> 适用于：独立开发者、Side Project、小团队
> 核心原则：快速验证、避免过度设计、保持节奏

---

## 一、整体流程概览

```
┌─────────────────────────────────────────────────────────────┐
│  1. 需求探索        PRD + 线框图 同步进行                    │
│         ↓                                                   │
│  2. 砍需求          确定 MVP 范围                           │
│         ↓                                                   │
│  3. 页面流程        用户怎么用？数据怎么流？                  │
│         ↓                                                   │
│  4. 数据建模        ER 图 + 表结构                          │
│         ↓                                                   │
│  5. API 设计        前端需要什么接口？                       │
│         ↓                                                   │
│  6. 开发            后端 → 前端 → 联调                       │
│         ↓                                                   │
│  7. 发布            部署 + 监控 + 反馈收集                   │
└─────────────────────────────────────────────────────────────┘
```

**关键认知：这不是瀑布流程，而是螺旋迭代。** 写代码时发现设计问题很正常，改就是了。

---

## 二、各阶段详解

### 2.0 关于文档的务实态度

> **核心原则：文档是工具，不是目的。**

| 文档类型 | 是否必须 | 说明 |
|----------|----------|------|
| PRD | **必须** | 时间久了自己都会忘，PRD 是产品的"北极星" |
| 线框图/流程图 | 复杂系统需要，简单系统脑子过 | 能帮你发现没想清楚的地方 |
| ER 图/字段说明 | **可选** | migration 本身就是可执行的文档 |
| API 文档 | 可选 | 代码注释 + Swagger 自动生成即可 |

**务实做法：**
```
PRD（必须）→ 复杂系统画图，简单系统脑子过 → 直接写 migration/代码
```

不要为了"规范"而写文档，要为了"解决问题"而写文档。

---

### 2.1 需求探索（PRD + 线框图）

**目标：** 搞清楚"给谁用、解决什么问题、怎么用"

**输出物：**
- PRD 文档（可以很简单，但必须有）
- 线框图/草图（复杂系统需要，简单系统可省略）

**常见错误：**
| 错误 | 后果 | 正确做法 |
|------|------|----------|
| 先写 PRD 再画图 | PRD 里很多"想当然"的地方 | 边写边画，互相验证 |
| 线框图画太精细 | 浪费时间，后面还会改 | 草图够用，能看懂就行 |
| 只写功能不写场景 | 功能做出来不知道怎么用 | 用"用户故事"描述：作为 XX，我想 XX，以便 XX |

**PRD 最小模板：**
```markdown
## 产品定位
- 目标用户：谁？
- 核心问题：解决什么痛点？
- 核心价值：用户为什么用你的而不是别的？

## 功能清单
- 功能 A：一句话描述
- 功能 B：一句话描述
- ...

## 用户场景
1. 场景一：用户在什么情况下打开产品，做什么操作，得到什么结果
2. 场景二：...
```

---

### 2.2 砍需求，确定 MVP

**目标：** 找到"最小可验证产品"——能跑通核心价值的最小功能集

**核心问题：**
> 没有这个功能，产品还能不能用？

**砍需求的优先级：**
```
必须有（Must Have）    → 进 MVP
应该有（Should Have）  → 放 v0.2
可以有（Nice to Have） → 放 Backlog
不确定的              → 先砍掉，等用户反馈
```

**常见错误：**
| 错误 | 心理原因 | 正确做法 |
|------|----------|----------|
| MVP 塞太多功能 | "都很重要" | 问自己：第一个用户愿意为哪个功能付费/持续使用？ |
| 功能做到 100% 再上线 | 完美主义 | 60% 完成度就上线，用户反馈比你猜的准 |
| 纠结技术选型 | 怕选错 | MVP 阶段技术不是瓶颈，先跑起来 |

---

### 2.3 页面流程 + 状态流

**目标：** 搞清楚用户怎么操作，数据怎么变化

**输出物：**
- 页面清单（有哪些页面）
- 页面流转图（从哪到哪）
- 核心状态流（数据状态怎么变）

**示例：任务系统的状态流**
```
创建 → active
        ↓
      完成 → done
        ↓
      归档 → archived
        ↓
      删除 → is_deleted = true
```

**常见错误：**
- 只画"正常流程"，不考虑异常情况（网络错误、数据为空、权限不足）
- 页面之间的跳转逻辑不清晰

---

### 2.4 数据建模（ER 图 + 表结构）

**目标：** 设计数据库结构，支撑业务需求

**流程：**
1. 识别核心实体（名词：用户、任务、资源...）
2. 识别实体关系（一对多、多对多）
3. 为每个实体设计字段
4. 添加索引、约束

**设计原则：**
| 原则 | 说明 |
|------|------|
| 先有数据再有索引 | 不要过早优化，等慢查询出现再加索引 |
| 枚举用 TEXT + CHECK | 比数据库 ENUM 更易演进 |
| 软删除优先 | is_deleted 比物理删除更安全 |
| 审计字段标配 | created_at, created_by, updated_at, updated_by |

**常见错误：**
| 错误 | 后果 | 正确做法 |
|------|------|----------|
| 表设计太细 | 到处 JOIN，查询复杂 | 适当冗余，读多写少的场景尤其如此 |
| 表设计太粗 | 字段越来越多，难以维护 | 职责单一，必要时拆表 |
| 不写 migration | 多环境数据库不一致 | 从第一天就用 migration |

---

### 2.5 API 设计

**目标：** 定义前后端的契约

**输出物：**
- API 清单（接口列表）
- 每个接口的请求/响应格式
- 错误码定义

**API 设计原则：**
```
1. URL 是名词，HTTP 方法是动词
   GET    /tasks      → 查询任务列表
   POST   /tasks      → 创建任务
   GET    /tasks/:id  → 查询单个任务
   PUT    /tasks/:id  → 更新任务
   DELETE /tasks/:id  → 删除任务

2. 响应格式统一
   成功：{ "code": 0, "data": {...} }
   失败：{ "code": 10001, "message": "任务不存在" }

3. 分页统一
   请求：?page=1&size=20
   响应：{ "list": [...], "total": 100, "page": 1, "size": 20 }
```

**常见错误：**
- 接口粒度太细，前端一个页面调 10 个接口
- 接口粒度太粗，返回一堆用不到的字段
- 错误码随便定义，前端不知道怎么处理

---

### 2.6 开发阶段

**推荐顺序：**
```
后端：
  1. DB migration（建表）
  2. 数据模型（ORM / struct）
  3. 核心 API（先跑通一个完整流程）
  4. 剩余 API

前端：
  1. 页面骨架（路由 + 空页面）
  2. 核心页面（对接后端 API）
  3. 剩余页面
  4. 样式优化

联调：
  - 边开发边联调，不要最后集中联调
```

**开发节奏建议：**
| 原则 | 说明 |
|------|------|
| 纵向切片 | 先做一个功能的完整链路（前端→后端→数据库），再做下一个功能 |
| 每天能看到进展 | 避免连续几天"在写代码但没东西能跑" |
| 及时提交 | 小步提交，commit message 写清楚 |

**常见错误：**
| 错误 | 后果 | 正确做法 |
|------|------|----------|
| 后端全写完再写前端 | 接口设计不合理，前端难用 | 纵向切片，边写边调 |
| 代码不提交 | 代码丢了 / 回滚困难 | 每完成一个小功能就提交 |
| 不写测试 | 改一处坏一片 | 至少写核心逻辑的单元测试 |

---

### 2.7 发布阶段

**MVP 发布清单：**
```
□ 部署环境准备（服务器 / 容器 / Serverless）
□ 域名 + HTTPS
□ 数据库备份策略
□ 基础监控（服务是否存活）
□ 错误日志收集
□ 用户反馈渠道
```

**发布后：**
- 观察用户行为，不是你想的那样用就对了
- 收集反馈，区分"真需求"和"伪需求"
- 快速迭代，一周一个小版本

---

## 三、时间分配建议（MVP 阶段）

| 阶段 | 占比 | 说明 |
|------|------|------|
| 需求 + 设计 | 20-30% | 想清楚再动手，但不要过度设计 |
| 开发 | 50-60% | 主要时间花在这里 |
| 联调 + 修 bug | 10-20% | 预留 buffer |
| 部署 + 发布 | 5-10% | 第一次部署会踩坑 |

**警告信号：**
- 设计阶段超过 40%：可能过度设计，开始写代码吧
- 开发阶段超过 70%：可能需求没想清楚，在反复返工

---

## 四、个人开发者特有的坑

### 4.1 完美主义陷阱

```
"这个架构不够优雅"
"这个 UI 不够好看"
"这个代码需要重构"
→ 结果：项目永远上不了线
```

**解药：** 问自己"用户在乎吗？"——用户在乎功能能不能用，不在乎你的代码优不优雅。

### 4.2 技术选型焦虑

```
"用 React 还是 Vue？"
"用 PostgreSQL 还是 MySQL？"
"要不要上微服务？"
→ 结果：还没开始就累了
```

**解药：** MVP 阶段，你熟悉什么就用什么。技术选型不是成败关键。

### 4.3 闭门造车

```
"等做完了再给人看"
"功能还不完善，不好意思发"
→ 结果：做了三个月，上线发现没人用
```

**解药：** 尽早让真实用户试用，哪怕只是朋友。他们的反馈比你的想象更有价值。

### 4.4 时间碎片化

```
"今天只有 1 小时，算了不写了"
"周末有空再集中写"
→ 结果：项目拖了半年
```

**解药：**
- 保持每天写一点的节奏，哪怕只有 30 分钟
- 每次结束前写下"明天从哪里开始"，降低启动成本

---

## 五、工具推荐

| 用途 | 工具 |
|------|------|
| PRD / 文档 | Markdown、Notion、语雀 |
| 线框图 | 纸 + 笔、Excalidraw、Figma |
| 任务管理 | GitHub Issues、Notion、滴答清单 |
| API 文档 | Swagger、Apifox、手写 Markdown |
| 代码管理 | Git + GitHub/GitLab |
| 部署 | Docker、Vercel、Railway、自建服务器 |

---

## 六、检查清单

### 开始开发前
```
□ PRD 能一句话说清楚产品是什么
□ MVP 功能列表明确，不超过 5 个核心功能
□ 核心页面的线框图画完
□ 数据库表结构确定
□ 技术选型确定
```

### 开发过程中
```
□ 每天有可见进展
□ 代码及时提交
□ 遇到问题及时记录（而不是"等会儿再说"）
```

### 发布前
```
□ 核心流程能跑通
□ 基础错误处理（网络错误、空数据）
□ 部署环境测试通过
□ 有收集用户反馈的渠道
```

---

## 七、最后的话

> **Done is better than perfect.**
> 完成比完美更重要。

个人开发者最大的敌人不是技术难度，而是：
1. 想太多，做太少
2. 追求完美，迟迟不发布
3. 没有用户反馈，闭门造车

**记住：** 你的第一个版本一定很烂，但只有发布了，才能开始变好。

---

> 本文档基于 learnnest 项目开发过程中的讨论整理
> 最后更新：2024/12/16
